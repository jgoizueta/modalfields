= ModalFields

This is a Rails Plugin to maintain schema information in the models' definitions.
It is a hybrid between HoboFields and model annotators.

It works like other annotators, by adding documentation to the model classes
from the DB schema. But the annotations are syntactic Ruby as in HoboFields rather than comments:

  class User < ActiveRecord::Base
    fields do
      name :string
      birthdate :date
    end
  end

Apart from looking prettier to my eyes, this allows triggering special functionality 
from the field declations (such as specifying validations).

Fields that are foreing_keys of belongs_to associations are not annotated; it is assumed that
belongs_to and other associations follow the fields block declaration, so the information
is readily available.

Primary keys named are also not annotated (unless the ModalFields.show_primary_keys property is changed)

The annotations are kept up to date by the migration tasks.
Comments and validation, etc. specifications modified manually are preserved, at least
if the field block syntax is kept as generated (one line per field, one line for the
block start and end...)

Custom type fields and hooks can be define in files (e.g. fields.rb) in config/initializers/

There's a couple of Rake tasks:
* fields:update is what's called after a migration; it updates the fields blocks in the model class definitions.
* fields:check shows the difference between the declared fields and the DB schema (what would be modified by fields:update)

== Some customization examples:

  ModalFields.hook do
  
    # Declare serialized fields as
    #  field_name :serialized, :class=>Array
    # another optionn would be: (using the generic hook)
    #  field_name :text, :serialize=>Array
    serialized do |model, declaration|
      model.serialize declaration.name, declaration.attributes[:class].class || Object
      declaration.replace!(:type=>:text).remove_attributes!(:class)
    end
  
    # Add specific support for date fields (_ui virtual attributes)
    date do |model, declaration|
      model.date_ui declaration.name
    end
  
    # Add specific support for date and datetime and detect fields with units
    all_fields do |model, declaration|
      date_ui name if [:date, :datetime].include?(declaration.type)
      if ModalSupport::Units.valid_units?(units = declaration.name.to_s.split('_').last)
        prec = {'m'=>1, 'mm'=>0, 'cm'=>0, 'km'=>3}[units] || 0      
        magnitude_ui name, prec, units
      end
    end
  
  end

  # Spatial Adapter columns: require specific column to declaration conversion and field types

  ModalFields.column_to_field_declaration do |column|
    type = column.type.to_sym
    type = column.geometry_type if type==:geometry
    attributes = {}
    attrs = ModalFields.definitions[type]
    attrs.keys.each do |attr|
      v = column.send(attr)          
      attributes[attr] = v unless attrs[attr]==v
    end
    ModalFields::FieldDeclaration.new(column.name.to_sym, type, [], attributes)
  end

  ModalFields.define do
    point               :srid=>nil, :with_z=>false, :with_m=>false
    line_string         :srid=>nil, :with_z=>false, :with_m=>false
    polygon             :srid=>nil, :with_z=>false, :with_m=>false
    geometry_collection :srid=>nil, :with_z=>false, :with_m=>false
    multi_point         :srid=>nil, :with_z=>false, :with_m=>false
    multi_line_string   :srid=>nil, :with_z=>false, :with_m=>false
    multi_polygon       :srid=>nil, :with_z=>false, :with_m=>false
    geometry            :srid=>nil, :with_z=>false, :with_m=>false
  end


  # Example: coded fields
  #   coded :numeric_code, :values=>{1=>:one, 2=>:two}
  ModalFields.hook do

    # Defines a field with integer codes which are associated with descriptions and optionally
    # with symbolic names. Constants for the codes are defined with the capitalized symbolic name.
    # Also a mapping from the codes to the symbolic names is stored in an CODIGOS_... constant and
    # is accesible by a ..._codigo class method.
    # Use:
    #   coded :name, :values=>{1=>[:first_symbol, 'First description'],...
    # or (automatic descriptions from symbolic names)
    #   coded :name, :values=>{1=>:first, 2=>:second,...
    # or (no constants defined))
    #   coded :name, :values=>{1=>'First', 2=>'Second'
    #
    # A model's class method, campo_codificado is used to the define the support methods for the field
    #
    coded do |model, declaration|
      descriptions = {}  # map from codes to descriptions
      symbols = {}       # map codes to symbols, to be stored in CODIGOS_... constant
      values = declaration.attributes[:values]
      values.each_pair do |code, symbol_descr|
        symbol,descr = symbol_descr
        if symbol.is_a?(String) && descr.nil?
          descr = symbol
        else
          descr ||= symbol.to_s.humanize
          model.const_set symbol.to_s.upcase, code
          symbols[code] = symbol
        end
        descriptions[code] = descr
      end
      declaration.replace!(:type=>:integer).remove_attributes!(:values)
      col = declaration.name
      model.campo_codificado col, descriptions
      unless symbols.empty?
        model.const_set "CODIGOS_#{col}", symbols
        mc = class <<model;self;end
        mc.instance_eval do
          define_method "#{col}_codigo" do |valor_codigo|
            const_get("CODIGOS_#{col}")[valor_codigo]
          end
        end
      end
    end 
  end

== Copyright

Copyright (c) 2011 Javier Goizueta. See LICENSE.txt for
further details.

